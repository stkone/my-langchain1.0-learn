"""
============================================================
Context Precision (上下文精确率) - Average Precision@K 计算演示
考虑位置和相关性
============================================================

【评估目标】
衡量RAG检索器返回的文档中有多少是相关的，同时考虑文档的排序位置。
排在前面的相关文档对分数贡献更大，鼓励检索器将最相关的文档优先返回。

【核心算法】Average Precision@K (AP@K)

【公式】
    AP = Σ(Precision@i × is_relevant_i) / 相关文档总数

    其中 Precision@i = 前i个文档中相关文档数 / i

【与简单命中率的区别】
┌─────────────────────────────────────────────────────────────────────┐
│  简单命中率计算（不考虑位置）：                                      │
│  • 只看相关文档数量占比                                             │
│  • [1,0,1,1,0] → 3/5 = 0.6                                         │
│  • [1,1,0,1,0] → 3/5 = 0.6 （相同结果）                            │
│                                                                     │
│  AP@K计算（考虑位置）：                                              │
│  • 相关文档越靠前，分数越高                                         │
│  • [1,0,1,1,0] → 0.8056                                            │
│  • [1,1,0,1,0] → 0.9167 （更高，因为相关文档排在前面）              │
│                                                                     │
│  【关键差异】AP@K惩罚"好文档排在后面"的情况，更符合实际使用体验      │
└─────────────────────────────────────────────────────────────────────┘
"""

import numpy as np


def _calculate_average_precision(verdict_list) -> float:
    """
    计算Average Precision@K

    【参数】
    verdict_list: List[int] - 检索结果的相关性判断列表
                 1表示相关，0表示不相关，按检索排序顺序排列

    【计算步骤】
    1. 分母 = 相关文档总数（+1e-10防止除零）
    2. 分子 = Σ(Precision@i × verdict_list[i])
       - Precision@i: 前i+1个文档的精确率
       - verdict_list[i]: 第i个文档是否相关（0或1）
    3. AP = 分子 / 分母

    【返回值】
    float: Average Precision分数，范围[0, 1]
    """
    score = np.nan

    # 分母：相关文档总数（+极小值防止除零错误）
    denominator = sum(verdict_list) + 1e-10

    # 分子：每个位置的精确率 × 该位置是否相关
    numerator = sum(
        [
            # Precision@i = 前i+1个中文档的相关数 / (i+1)
            # 乘以verdict_list[i]：只有相关文档才计入分子
            (sum(verdict_list[: i + 1]) / (i + 1)) * verdict_list[i]
            for i in range(len(verdict_list))  # i = 0, 1, 2, 3, 4
        ]
    )

    print(f"相关文档数(分母): {denominator}")
    print(f"加权和(分子): {numerator}")

    score = numerator / denominator
    return score


# ============================================================
# 示例1: 相关文档分布在第1、3、4位
# ============================================================
verdict_list = [1, 0, 1, 1, 0]
print("=" * 50)
print("示例1: verdict_list = [1, 0, 1, 1, 0]")
print("-" * 50)

score = _calculate_average_precision(verdict_list)
print(f"AP@K得分: {score:.4f}")

print("""
【详细计算过程】
┌─────────┬─────────────┬──────────────┬─────────────┬─────────────┐
│ 位置(i) │ 是否相关    │ 前i+1相关数  │ Precision@i │ 贡献值      │
├─────────┼─────────────┼──────────────┼─────────────┼─────────────┤
│    0    │      1      │       1      │   1/1=1.0   │ 1.0 × 1=1.0 │
│    1    │      0      │       1      │   1/2=0.5   │ 0.5 × 0=0   │
│    2    │      1      │       2      │   2/3≈0.667 │0.667×1=0.667│
│    3    │      1      │       3      │   3/4=0.75  │0.75 × 1=0.75│
│    4    │      0      │       3      │   3/5=0.6   │ 0.6 × 0=0   │
└─────────┴─────────────┴──────────────┴─────────────┴─────────────┘
分子总和 = 1.0 + 0 + 0.6667 + 0.75 + 0 = 2.4167
分母 = 相关文档总数 = 3
AP@K = 2.4167 / 3 ≈ 0.8056
""")

# ============================================================
# 示例2: 相关文档分布在第1、2、4位（更靠前）
# ============================================================
verdict_list = [1, 1, 0, 1, 0]
print("=" * 50)
print("示例2: verdict_list = [1, 1, 0, 1, 0]")
print("-" * 50)

score = _calculate_average_precision(verdict_list)
print(f"AP@K得分: {score:.4f}")

print("""
【详细计算过程】
┌─────────┬─────────────┬──────────────┬─────────────┬─────────────┐
│ 位置(i) │ 是否相关    │ 前i+1相关数  │ Precision@i │ 贡献值      │
├─────────┼─────────────┼──────────────┼─────────────┼─────────────┤
│    0    │      1      │       1      │   1/1=1.0   │ 1.0 × 1=1.0 │
│    1    │      1      │       2      │   2/2=1.0   │ 1.0 × 1=1.0 │
│    2    │      0      │       2      │   2/3≈0.667 │0.667× 0=0   │
│    3    │      1      │       3      │   3/4=0.75  │0.75 × 1=0.75│
│    4    │      0      │       3      │   3/5=0.6   │ 0.6 × 0=0   │
└─────────┴─────────────┴──────────────┴─────────────┴─────────────┘
分子总和 = 1.0 + 1.0 + 0 + 0.75 + 0 = 2.75
分母 = 相关文档总数 = 3
AP@K = 2.75 / 3 ≈ 0.9167
""")

print("=" * 50)
print("【对比总结】")
print("-" * 50)
print("""
两个示例都有3个相关文档（命中率都是3/5=0.6）
但AP@K得分不同：
  • 示例1 [1,0,1,1,0]: AP = 0.8056（相关文档分散）
  • 示例2 [1,1,0,1,0]: AP = 0.9167（相关文档靠前）

【结论】AP@K不仅关注"有多少相关文档"，更关注"相关文档在哪里"。
这种计算方式更符合实际RAG系统的使用体验——用户更倾向于看到
相关文档排在检索结果的前面。
""")